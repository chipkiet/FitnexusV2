#!/usr/bin/env node
/**
 * Simple helper: ensure frontend Vite dev env uses the backend port/url
 * defined in packages/backend/.env so the dev proxy works like production.
 */
import fs from "fs/promises";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.resolve(__dirname, "..");

const backendEnvPath = path.join(projectRoot, "packages", "backend", ".env");
const frontendEnvPath = path.join(projectRoot, "packages", "frontend", ".env.development.local");

function parseEnv(content = "") {
  return content.split(/\r?\n/g).reduce((acc, rawLine) => {
    const line = rawLine.trim();
    if (!line || line.startsWith("#")) return acc;
    const idx = line.indexOf("=");
    if (idx === -1) return acc;
    const key = line.slice(0, idx).trim();
    if (!key) return acc;
    let value = line.slice(idx + 1).trim();
    if (
      (value.startsWith('"') && value.endsWith('"')) ||
      (value.startsWith("'") && value.endsWith("'"))
    ) {
      value = value.slice(1, -1);
    }
    acc[key] = value;
    return acc;
  }, {});
}

async function readFileSafe(filePath) {
  try {
    return await fs.readFile(filePath, "utf8");
  } catch (error) {
    if (error.code === "ENOENT") return null;
    throw error;
  }
}

function updateEnvValue(content = "", key, value) {
  const lines = content.split(/\r?\n/g);
  let found = false;
  const next = lines.map((line) => {
    if (line.trim().startsWith("#")) return line;
    const idx = line.indexOf("=");
    if (idx === -1) return line;
    const lineKey = line.slice(0, idx).trim();
    if (lineKey !== key) return line;
    found = true;
    return `${key}=${value}`;
  });
  if (!found) next.push(`${key}=${value}`);
  return next.join("\n").replace(/\s+$/, "") + "\n";
}

function ensureHttp(urlString, port) {
  const trimmed = (urlString || "").trim();
  if (/^https?:\/\//i.test(trimmed)) return trimmed.replace(/\/+$/, "");
  return `http://localhost:${port}`;
}

function rel(p) {
  return path.relative(projectRoot, p) || ".";
}

const backendEnvRaw = await readFileSafe(backendEnvPath);
if (!backendEnvRaw) {
  console.warn(`[dev-sync] Bỏ qua: không tìm thấy ${rel(backendEnvPath)}.`);
  process.exit(0);
}

const backendEnv = parseEnv(backendEnvRaw);
const backendPort = Number(backendEnv.PORT) || 3001;
const backendUrl = ensureHttp(backendEnv.BACKEND_URL, backendPort);

let backendEnvNext = backendEnvRaw;
if (!backendEnv.BACKEND_URL || ensureHttp(backendEnv.BACKEND_URL, backendPort) !== backendUrl) {
  backendEnvNext = updateEnvValue(backendEnvNext, "BACKEND_URL", backendUrl);
}
if (backendEnvNext !== backendEnvRaw) {
  await fs.writeFile(backendEnvPath, backendEnvNext, "utf8");
}

let frontendEnvRaw = await readFileSafe(frontendEnvPath);
if (!frontendEnvRaw) {
  frontendEnvRaw = "# Auto-generated by scripts/sync-dev-ports.mjs\n";
}
const nextFrontendEnv = updateEnvValue(frontendEnvRaw, "VITE_BACKEND_URL", backendUrl);
if (nextFrontendEnv !== frontendEnvRaw) {
  await fs.writeFile(frontendEnvPath, nextFrontendEnv, "utf8");
}

console.log(
  `[dev-sync] Backend PORT=${backendPort}, URL=${backendUrl}. ${rel(frontendEnvPath)} đã được đồng bộ.`,
);
